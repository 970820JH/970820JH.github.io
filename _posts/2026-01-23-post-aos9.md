---
title: "모바일(AOS)진단 9 - 단말 취약점 진단 (메모리 내 중요 정보 평문 노출)"
categories:
  - 모바일(AOS)
tags:
  - 모바일(AOS)
---

안드로이드 앱은 실행 시 사용할 메모리 영역을 할당받고, 메모리에는 실행 코드와 사용할 리소스가 저장됨

안드로이드 런타임은 페이징과 메모리 매핑을 이용해서 메모리를 관리한다. 메모리를 관리하기 위해 자바에서는 동적으로 할당했던 메모리 영역 중 사용하지 않는 메모리를 주기적으로 삭제하는
가비지 컬렉션을 수행함


운영체제 수준에서 메모리를 관리하기 때문에 개발자 기능개발에 용이하지만, 앱에서 메모리를 할당하고 해제하는 시점과 위치를 예상할 수 없고 시스템에서 판단하기 때문에 메모리에 사용하지 않는 데이터가 계속해서 남아있을 수 있음. 사용자가 앱을 닫더라도 앱의 프로세스는 종료되지 않고 캐시에 저장됨.또는 백그라운드에서 동작하는 앱은 화면이 표시되지 않는 상태에서도 실행을 유지할 수 있도록 메모리가 관리된다. 앱에서 사용하는 메모리는 앱의 화면 표시 여부에 관계없이 앱의 생명주기에 따라 관리됨

자바의 정적 변수는 클래스 수준에서 선언되며 클래스 인스턴스의 생성 여부와 관계없이 하나의 복사본이 존재함. 
 cf. 클래스 수준 
 class User{
        string name;  // 인스턴스 변수(객체마다 각자 다른값 a.name -> 객체마다 복사본 N개)
        static int usercount;      // 정적변수(모든 객체가 같은 값 공유 -> 클래스당 복사본 1개)
 }

 User a = new User();       // 클래스 인스턴스(클래스로 실제로 만들어진 객체로 new로 생성)

앱이 실행되는 동안 이 변수들은 계속해서 메모리에 남아있으며, 해당 클래스에
접근 가능한 위치와 관계없이 사용할 수 있다. 만약 중요 정보가 정적변수에 저장되는 경우, 해당 정보는 앱 실행 동안 메모리에 남아있게 된다. 디버깅 도구를 통한 앱의 메모리 덤프 또는 스냅샷 생성 시 포함될 수 있음. 스냅샷은 현재의 메모리 상태를 사진을 직듯이 그대로 복사해오는 기능으로 리소스의 할당상태나 데이터 처리 과정에서의 메모리 구조를 포함한 복사본을 제공함


정적으로 선언된 변수나 액티비티를 한 번이라도 직접 또는 간접적으로 참조하면 액티비티가 종료된 이후에도 가비지 컬렉터가 사용하지 않는 메모리를 회수하지 않을 수 있음. 

또한 최적화되지 않은 외부 라이브러리 사용도 문제를 일으킬 수 있음(모바일 환경을 예상하지 않고 작성된 외부 라이브러리 NDK 경우, 개발자가 직접 메모리 관리 함수를 사용하여 메모리를 할당하고 사용해야함)




JNI를 이용한 중요 정보 처리 코드 (JNI에서 민감 정보를 다루면서 메모리 흔적을 지우는 예시)

```
NDK/JNI의 본질, 흐름은 Java/Kotlin에서 C로 흐름
JNIEXPORT void JNICALL Java_com_example_Myclass_storeSensitiveDate(JNIEnv*env, jobject obj, jstring j_name j_password){
    struct SensitiveData{               // 민감 정보를 임시저장하기 위한 C구조체
        char name[64];
        char password[64];
    } data;

    const char *name = (*env)->GetStringUTFChars(env, j_name, 0);               // 자바의 jstring을 c에서 사용 가능한 UTF-8 문자열로 변환
    const char *password = (*env)->GetStringUTFChars(env, j_password, 0);       

    strncpy(data.name, name, sizeof(data.name));                                // 변환된 c문자열을 구조체의 버퍼로 복사
    strncpy(data.password, password, sizeof(data.password));

    memset(&data, 0, sizeof(data));             // 구조체 전체를 0으로 덮어씀 (여기서부터 중요정보 처리 0으로 덮고, 사용이 끝났다고 호출)

// JVM 내부 리소스 해제 및 메모리 누수 방지를 위해 사용이 끝났음을 알림
    (*env)->ReleaseStringUTFChars(env, j_name, name);
    (*env)->ReleaseStringUTFChars(env, j_password, password);

}

```

C에서 malloc함수와 free함수를 사용하여 메모리를 할당하고 해제함
malloc함수는 필요한 메모리 크기를 인자로 받아 해당 크기의 메모리를 동적으로 할당
이후 memset함수 메모리 블록내의 내용을 특정 값으로 설정하여 데이터를 초기화
free함수는 malloc을 통해 할당된 메모리를 해제하는데 사용

액티비티의 레이라룻 파일에서 중요 정보를 입력받는 폼 속성에 일반 텍스트로 지정되어 있는 경우 사용자가 입력했을 때 키보드 캐시에 값이 저장됨
민감한 정보를 입력받는 필드에 대해서는 키보드 캐시에 저장되지 않도록 설정해야함


```

메모리에 저장되는 입력 폼 설정 (안드로이드에서 UI는 XML이라는 설정파일로 분리해서 정의)

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/APK/res/android"
    xmlns:app="http://schemas.android.com/APK/res-auto">
    <EditText
        android:id="@+id/KeyBoardCache"      // 코드에서 접근하기 위한 view ID
        android:inputType="text" />          // 중요정보 입력 폼의 타입 변경(text:일반 텍스트 입력으로 키보드 캐시 사용 가능 / 중요정보 입력 폼에는 부적절)
</LinearLayout>

```