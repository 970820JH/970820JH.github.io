---
title: "모바일(AOS)진단 9 - 단말 취약점 진단 (메모리 내 중요 정보 평문 노출)"
categories:
  - 모바일(AOS)
tags:
  - 모바일(AOS)
---

안드로이드 앱은 실행 시 사용할 메모리 영역을 할당받고, 메모리에는 실행 코드와 사용할 리소스가 저장됨

안드로이드 런타임은 페이징과 메모리 매핑을 이용해서 메모리를 관리한다. 메모리를 관리하기 위해 자바에서는 동적으로 할당했던 메모리 영역 중 사용하지 않는 메모리를 주기적으로 삭제하는
가비지 컬렉션을 수행함


운영체제 수준에서 메모리를 관리하기 때문에 개발자 기능개발에 용이하지만, 앱에서 메모리를 할당하고 해제하는 시점과 위치를 예상할 수 없고 시스템에서 판단하기 때문에 메모리에 사용하지 않는 데이터가 계속해서 남아있을 수 있음. 사용자가 앱을 닫더라도 앱의 프로세스는 종료되지 않고 캐시에 저장됨.또는 백그라운드에서 동작하는 앱은 화면이 표시되지 않는 상태에서도 실행을 유지할 수 있도록 메모리가 관리된다. 앱에서 사용하는 메모리는 앱의 화면 표시 여부에 관계없이 앱의 생명주기에 따라 관리됨

자바의 정적 변수는 클래스 수준에서 선언되며 클래스 인스턴스의 생성 여부와 관계없이 하나의 복사본이 존재함. 앱이 실행되는 동안 이 변수들은 계속해서 메모리에 남아있으며, 해당 클래스에
접근 가능한 위치와 관계없이 사용할 수 있다. 만약 중요 정보가 정적변수에 저장되는 경우, 해당 정보는 앱 실행 동안 메모리에 남아있게 된다. 디버깅 도구를 통한 앱의 메모리 덤프 또는 스냅샷 생성 시 포함될 수 있음. 스냅샷은 현재의 메모리 상태를 사진을 직듯이 그대로 복사해오는 기능으로 리소스의 할당상태나 데이터 처리 과정에서의 메모리 구조를 포함한 복사본을 제공함


정적으로 선언된 변수나 액티비티를 한 번이라도 직접 또는 간접적으로 참조하면 액티비티가 종료된 이후에도 가비지 컬렉터가 사용하지 않는 메모리를 회수하지 않을 수 있음. 또한 최적화되지 않은
외부 라이브러리 사용도 문제를 일으킬 수 있음(모바일 환경을 예상하지 않고 작성된 외부 라이브러리 NDK 경우, 개발자가 직접 메모리 관리 함수를 사용하여 메모리를 할당하고 사용해야함)


JNI를 이용한 중요 정보 처리 코두

```
JNIEXPORT void JNICALL Java_com_example_Myclass_storeSensitiveDate(JNIEnv*env, jobject obj, jstring j_name j_password){
    struct SensitiveData{
        char name[64];
        char password[64];
    } data;

    const char *name = (*env)->GetStringUTFChars(env, j_name, 0);
    const char *password = (*env)->GetStringUTFChars(env, j_password, 0);       // 자바에서 전달받은 문자열을 C 문자열로 변환

    strncpy(data.name, name, sizeof(data.name));
    strncpy(data.password, password, sizeof(data.password));

    memset(&data, 0, sizeof(data));

    (*env)->ReleaseStringUTFChars(env, j_name, name);
    (*env)->ReleaseStringUTFChars(env, j_password, password);
    
}




```