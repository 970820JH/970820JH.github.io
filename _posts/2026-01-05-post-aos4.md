---
title: "모바일(AOS)진단 4 - 단말 취약점 진단 (로컬저장소 내 중요정보 확인)"
categories:
  - 모바일(AOS)
tags:
  - 모바일(AOS)
---

>   **앱별 저장소 (안드로이드 디바이스 디렉터리 구조)** <br>

내부 저장소(Internal Storage)와 외부 저장소(External Storage)로 구분<br>
<br>
내부 저장소(Internal Storage) → /data/data/[패키지명]/  <br>
<br>
**/data/data/[패키지명]/cache**: 앱의 캐시 파일, 임시 파일이나 빠른 데이터 접근을 위한 캐시 파일<br>
**/data/data/[패키지명]/databases** : 데이터베이스 관련 내장형 SQLite<br>
**/data/data/[패키지명]/files** : 앱이 생성한 파일, 사용자가 생성한 파일이나 다운로드한 파일, 앱 설정<br>
**/data/data/[패키지명]/lib** : 앱의 네이티브 코드 라이브러리<br>
**/data/data/[패키지명]/shared_prefs** : 앱의 설정이나 사용자 데이터, 상태 정보(사용자 세션 상태나 로그인정보/자동 로그인) 저장, XML파일로 키-값으로 이뤄짐<br>
**/data/data/[패키지명]/app_webview** : 웹뷰(웹페이지HTML로 구성) -> 웹뷰 앱이란 앱이 내부적으로 브라우저를 띄워 웹 페이지를 실행하는 구조<br>
<br>
CF. 앱 설치 시 OS가 기본적으로 만들어주는 것 : cache, databases, files, lib, shared_prefs, code_cache, app_webview(WebView사용시), no_backup(API21+)<br>
그외는 개발자가 앱 코드에서 생성한 커스텀 디렉터리<br>

```
new File(context.getFilesDir(), "logs").mkdirs();  ->/data/data/패키지명/files/logs/ 이런식으로 생성
```





<br>
<br>
외부 저장소(External Storage) → SD카드와 같은 외부 저장소 (모든 앱이 접근하여 파일을 읽고 쓸 수 있으므로 민감한 정보 저장x)

**취약점 정의 : 환경설정 정보, 외부 API연동 및 토큰 값, 연동 서버 정도 등 로컬 스토리지에 저장. 루팅 환경에서는 애플리케이션이 다른 애플리케이션의 디렉터리에 접근할 수 있으므로 탈취 위험**<br><br>

<img src="/assets/images/icon/directory.png"  style="display:block; margin:0 auto; width:90%; border:1px solid #000;"><br>
<br>
<br>
<br>


>   **취약한 예시 및 조치 암호화 관련** <br>


```
*취약한 예시 (문자열 평문으로 그대로 저장)
SharedPreferences prefs =
    getSharedPreferences("user_prefs", MODE_PRIVATE);   // /data/data/패키지명/shared_prefs/user_prefs.xml

prefs.edit()                                            //SharedPreferences는 읽기 전용, edit()을 호출해서 쓰기 모드
     .putString("token", accessToken)                   // 평문 저장 노출
     .putString("userId", userId)
     .apply();
```

```
*조치 암호화 관련

＊EncryptedSharedPreferences클래스     // Android Keystors는 내부적으로 안드로이드 키스토어(키를 OS가 관리) 사용함 (키스토어 내부적으로 자동 사용/개발자가 api 직접 호출x)

MasterKey masterKey = new MasterKey.Builder(context)
    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)     // AES-256-GCM방식으로 암호 키 생성
    .build();                                         // 키는 안드로이드 키스토어에 저장

SharedPreferences securePrefs =
    EncryptedSharedPreferences.create(                // 보안 라이브러리가 제공하는 함수
        context,                                      // 저장소를 사용하는 앱 식별 정보
        "secure_prefs",                               // 저장 파일 이름
        masterKey,                                    
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,   // 키 자체도 암호화
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM  //  value(실제 데이터) 암호화 방식
    );

securePrefs.edit()
    .putString("token", accessToken)   // 실제파일에는 둘 다 암호화된 상태로 저장
    .apply();

-----------------------------------------------------------------------------------

*Android Keystore // 키스토어 직접 사용 (키스토어를 직접 제어)
KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");    // 키스토어 인스턴스 가져오기
keyStore.load(null);

-----------------------------------------------------------------------------------

* 키스토어 인스턴스 호출 -> 내가 쓰려는 별명 키가 없으면 직접 만들어 넣음
String KEY_ALIAS = "db_aes_key";

if (!keyStore.containsAlias(KEY_ALIAS)) {

    KeyGenerator keyGenerator =
        KeyGenerator.getInstance(
            KeyProperties.KEY_ALGORITHM_AES,
            "AndroidKeyStore"
        );

    KeyGenParameterSpec keySpec =
        new KeyGenParameterSpec.Builder(
            KEY_ALIAS,
            KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT
        )
        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
        .setKeySize(256)
        .build();

    keyGenerator.init(keySpec);
    keyGenerator.generateKey();
}

-----------------------------------------------------------------------------------

*SQLCipher (DB 전체 암호화)    //SQLite 데이터베이스 파일 자체를 통째로 암호화해주는 보안 라이브러리(AES-256기반)
SQLiteDatabase db =
  SQLiteDatabase.openOrCreateDatabase(       // 파일 단위로 처리됨
    dbFile,                                  // ex. /data/data/<패키지명>/databases/secure.db
    "dbPassword",                            // db를 여는 암호키 (하드코딩시 취약점)
    null
  );

-----------------------------------------------------------------------------------

*암호화 유틸 (AES + 키스토어) → 컬럼/값 단위 암호화(마찬가지로 키스토어 인스턴스 호출하고)

-----------------------------------------------------------------------------------

*파일 저장 시 직접 암호화
ublic void encryptAndSaveToFile(Context context, String filename, String plainText)
        throws Exception {

    KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");    // 키스토어 접근
    keyStore.load(null);

    SecretKey secretKey =
        ((KeyStore.SecretKeyEntry)
            keyStore.getEntry("file_aes_key", null))
            .getSecretKey();

    // Cipher 생성 (AES-256-GCM) (파일 저장 시 직접 암호화 여기가 포인트)
    Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);

   // 초기화 백터 (초기화 백터가 하드코딩되어있는건 문제없지만 고정된 동일한 값을 사용하는것을 취약)
    byte[] iv = cipher.getIV();
    byte[] cipherText =
        cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));

    // 파일에 저장 (IV + 암호문)
    FileOutputStream fos =
        context.openFileOutput(filename, Context.MODE_PRIVATE);

    fos.write(iv);
    fos.write(cipherText);
    fos.close();


```